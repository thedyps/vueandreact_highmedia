<script>
    //ES6에서 함수 도입: "화살표 함수(arrow function)" : =>
    //비교 연산자 : <=, >=

    //기존 함수
    //일반함수: 직접 함수를 호출
    function add1(a, b) {
        return a + b;
    }
    console.log(add1(7,8));

    //익명함수: 간접 함수 호출
    const add2 = function(x, y) {
        return x + y;    
    }
    console.log(add2(6,9));

    //Arrow Function
    const add3 = (x, y) => x + y;
    console.log(add3(21, 10));

    //화살표함수의 적용, function을 제거 / {} 대신 '=>'을 작성한다.
    //(단 조건은 {}실행문 내부에 return문만 선언되었을 때);
    //함수 실행은 내부에 return문 이외의 문구 작성시 {}는 존재해야함

    const add4 = (x, y) => {
        const a = 13;
        return a + x + y;
    }
    console.log(add4(4,5));

    //매개변수가 하나인 경우 - 방법1
    const add5 = (g) => g+9;
    console.log(add5(6, 24));   
    
    //매개변수가 하나인 경우 - 방법2
    const add6 = g => g+9;
    console.log(add6(6,24));

    //매개변수가 존재하지 않는 경우
    const add = () => {
        console.log("add7 함수 구문 실행")
    }

    //Hoisting: 소형 감아올리는 장치 => 일반함수구문에서는 아직 로딩이 안된 상태임에도 불구하고 문서상에 상단으로 올리는 현상
    fnc1();
    function fnc1() {
        console.log("fnc1 호출에 의한 함수구문 시행");
    }

    //fnc2(); //Uncaught ReferenceError: Cannot access 'fnc2' before initialization
    const fnc2 = function() {
        console.log("fnc2 호출에 의한 함수구문 시행");
    }
    fnc2();

    //실습문제 
    //세개의 숫자 합계를 화살표 함수를 이용하여 콘솔창에 출력하시오
    //함수호출문을 통해서 1,2,3을 함수구문에 전달하고 '최종합계'는 6이라는 값을 콘솔창에 출력
    const add7 = (x,y,z) => x+y+z;
    console.log(`최종합계는 ${add7(1,2,3)}입니다`); 
</script>

<h1 id="ch_txt">스누피</h1>
<!--#1. "스누피"라는 문구를 "카카오"로 변경하시오-->
<!--#2. "스누피"라는 문구를 "스머프"로 변경하고, 함수 내부에서 리턴을 받아서 콘솔창에 결과물을 출력: 스머프 만세-->
<script>

    const changeTxt = (x) => document.querySelector("#ch_txt").textContent = x;
    console.log(changeTxt("카카오"));

    const changeTxt2 = (x) => {
        document.querySelector("#ch_txt").textContent = x;
        return `${x} 만세`;
    } 
    console.log(`${changeTxt2("스머프")}`);
</script>


    <hr/>
    <h3 id="arrowFunc_this">화살표 함수와 this의 관계 / function과 this의 관계</h3>
    <div class=".box .opening">
        나는 박스
    </div>

    <style>
    .open{
        width: 200px;
        height: 200px;
        border: 1px solid black;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    .opening {
        background-color: #ff6;

    }
    </style>

    <script>
        const $box = document.querySelector(".box");
        console.log($box);

        /*
        $box.addEventListener("click", function() {
            console.log(this);
            this.classList.add("opening");
        });
        */

        /*
        $box.addEventListener("click", () => {
            console.log(this);

        });
        */

        //화살표 함수가 부모 스코프 {}에서 this 값을 상속한다는것을 인지한다면 에러 발생르 막기 위해 일반함수로 반드시 작성한다.
    </script>

    <!-- 객체에서도 메서드의 설정에서 함수로 작성되는데 , this의 키워드 대상에 따라서 작성하는 방법을 달리해야함-->
    
    <script>
        const person = {
            age: 10,
            grow: function () {
                console.log(this);
                console.log(this.age);
                console.log(person.log);
                this.age++;
                console.log(this.age);
            }
        }
        console.log(person.age)
        person.grow();
        
        const person2 = {
            age: 10,
            grow: () => {
                console.log(this);
                this.age++;
                console.log(this.age);
            }
        }
        person2.grow();
    </script>


<!--arguments 객체-->
<script>
    //일반함수 내부에서 arguments 객체의 선언
    function example0() {
        console.log(arguments[0]);
    }
    example0(1,2,3)

    //익명함수 내부에서 arguments 객체의 선언
    const example1 = function() {
        console.log(arguments[0]);

    }
    example1('a', 'b', 'c');

    //화살표 함수 내부에서 argument 객체의 선언
    const example2 = () => {
        console.log(arguments);
    }
    //example2('asus', 'gigabyte', 'msi');

    const example4 = (...args) => {
        console.log(args); //['asus', 'gigabyte', 'msi']
    }

    example4('asus', 'gigabyte', 'msi');

</script>